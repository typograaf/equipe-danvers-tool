<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Equipe d'Anvers — Story Builder</title>
<link rel="icon" type="image/png" href="Sources/favicon.png">
<link rel="apple-touch-icon" href="Sources/webclip.png">
<script type="module">
  import * as mp4Muxer from 'https://cdn.jsdelivr.net/npm/mp4-muxer@5.1.3/+esm';
  window.mp4Muxer = mp4Muxer;
</script>
<style>
@font-face {
  font-family: 'Monotalic';
  src: url('Sources/Monotalic-WideMedium.ttf') format('truetype');
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  background: #000;
  color: #fff;
  font-family: 'Monotalic', monospace;
  font-size: 10px;
  line-height: 1.18;
  letter-spacing: 4px;
  text-transform: uppercase;
  height: 100vh;
  overflow: hidden;
  display: flex;
}

.wrap {
  display: flex;
  width: 100%;
  height: 100%;
  padding: 10px;
  gap: 10px;
}

/* ——— FORM PANEL ——— */
.form-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  padding: 24px;
  overflow-y: auto;
  min-width: 0;
}

.form-inner {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

/* section = label + fields, spaced by line-height only */
.section {
  display: flex;
  flex-direction: column;
  gap: 0;
}

.section-label {
  opacity: 0.3;
  display: block;
  margin-bottom: 4px;
}

/* each field is label + input on one line */
.field {
  display: flex;
  align-items: baseline;
}

.field + .field {
  margin-top: 0; /* lines sit at natural line-height */
}

.lbl {
  flex-shrink: 0;
  white-space: nowrap;
  margin-right: 0.4ch;
}

input[type="text"],
textarea {
  flex: 1;
  background: transparent;
  border: none;
  outline: none;
  color: #fff;
  font-family: 'Monotalic', monospace;
  font-size: 10px;
  line-height: 1.18;
  letter-spacing: 4px;
  text-transform: uppercase;
  padding: 0;
  margin: 0;
  caret-color: #fff;
  resize: none;
  overflow: hidden;
  display: block;
  width: 100%;
  min-width: 0;
}

textarea { min-height: calc(10px * 1.18); }

input::placeholder,
textarea::placeholder { opacity: 0.25; }

/* Mode toggle */
.toggle-row {
  display: flex;
  gap: 6px;
  margin-top: 4px;
}

.toggle-btn {
  height: 16px;
  width: 96px;
  border-radius: 999px;
  border: 1px solid #fff;
  background: transparent;
  cursor: pointer;
  transition: background 0.15s;
  padding: 0;
  appearance: none;
  -webkit-appearance: none;
}

.toggle-btn.active { background: #fff; }

/* action links */
.action {
  cursor: pointer;
  display: block;
  margin-top: 4px;
}
.action:hover { opacity: 0.6; }

.status {
  opacity: 0.3;
  font-size: 10px;
  letter-spacing: 4px;
  display: block;
  min-height: calc(10px * 1.18);
}

/* Footer */
.form-footer {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  padding-top: 24px;
  flex-shrink: 0;
}

.monogram-footer {
  height: 18px;
  width: auto; /* preserve 143:84 ratio */
  filter: invert(1);
  flex-shrink: 0;
}

/* ——— PREVIEW PANEL ——— */
.preview-panel {
  flex-shrink: 0;
  display: flex;
  align-items: center;
  height: 100%;
}

.preview-wrap {
  border: 2px solid rgba(255,255,255,0.4);
  border-radius: 7px;
  overflow: hidden;
}

#preview {
  display: block;
  /* Width is set by JS after each render. Height follows intrinsic ratio. */
  height: auto;
}

/* ——— SPACER ——— */
.spacer { flex: 1; min-width: 0; }

/* ——— MOBILE ——— */
@media (max-width: 768px) {
  body {
    height: auto;
    min-height: 100vh;
    overflow-y: auto;
    overflow-x: hidden;
  }

  .wrap {
    flex-direction: column;
    height: auto;
    align-items: stretch;
    padding: 10px;
    gap: 0;
  }

  /* Preview sits above the form */
  .preview-panel {
    order: -1;
    width: 100%;
    height: auto;
    justify-content: center;
    padding-bottom: 10px;
  }

  .preview-wrap {
    margin: 0 auto;
  }

  .form-panel {
    overflow-y: visible;
    flex: none;
    padding: 16px 0;
  }

  .form-footer {
    padding-top: 16px;
    flex-wrap: wrap;
    gap: 12px;
  }

  .spacer { display: none; }

  /* 16px minimum prevents iOS Safari from auto-zooming on input focus */
  input[type="text"],
  textarea {
    font-size: 16px;
  }

  /* Larger tap targets for action links */
  .action {
    padding: 6px 0;
    margin-top: 0;
  }

  .toggle-btn {
    height: 24px;
    width: 80px;
  }
}
</style>
</head>
<body>
<div class="wrap">

  <!-- FORM PANEL -->
  <div class="form-panel">
    <div class="form-inner">

      <div>
        <p>Equipe d'Anvers</p>
        <p>(IG) Story Builder</p>
      </div>

      <!-- Identity -->
      <div class="section">
        <span class="section-label">Identity</span>
        <div class="field"><span class="lbl">No.:</span><input type="text" id="f-number" placeholder="02" autocomplete="off"></div>
        <div class="field"><span class="lbl">Name:</span><input type="text" id="f-name" placeholder="Horse name" autocomplete="off"></div>
        <div class="field"><span class="lbl">Line 1:</span><input type="text" id="f-line1" placeholder="Mother" autocomplete="off"></div>
        <div class="field"><span class="lbl">Line 2:</span><input type="text" id="f-line2" placeholder="Father" autocomplete="off"></div>
      </div>

      <!-- Competition -->
      <div class="section">
        <span class="section-label">Competition</span>
        <div class="field"><span class="lbl">Place:</span><input type="text" id="f-place" placeholder="Peelbergen" autocomplete="off"></div>
        <div class="field"><span class="lbl">Height:</span><input type="text" id="f-height" placeholder="1.20" autocomplete="off"></div>
      </div>

      <!-- Notes -->
      <div class="section">
        <span class="section-label">Notes</span>
        <textarea id="f-notes" placeholder="Extra information..."></textarea>
      </div>

      <!-- Mode -->
      <div class="section">
        <span class="section-label">Mode</span>
        <div class="toggle-row">
          <button class="toggle-btn active" id="btn-dark"  onclick="setMode('dark')"></button>
          <button class="toggle-btn"        id="btn-light" onclick="setMode('light')"></button>
        </div>
      </div>

      <!-- Source -->
      <div class="section">
        <span class="section-label">Source</span>
        <span class="action" onclick="document.getElementById('video-input').click()">→ Upload video</span>
        <input type="file" id="video-input" accept="video/*" style="display:none">
        <span class="status" id="video-name"></span>
      </div>

      <!-- Export -->
      <div class="section">
        <span class="section-label">Export</span>
        <span class="action" id="btn-export" onclick="startExport()">→ Export video</span>
        <span class="status" id="export-status"></span>
      </div>

    </div>

    <!-- Footer -->
    <div class="form-footer">
      <img src="Sources/Monogram.svg" class="monogram-footer" alt="E D'A">
      <p>A Graphic Tool<br>by Typograaf</p>
      <p>Version 01<br>2026/02/28</p>
    </div>
  </div>

  <!-- PREVIEW -->
  <div class="preview-panel">
    <div class="preview-wrap">
      <canvas id="preview" width="810" height="1440"></canvas>
    </div>
  </div>

  <div class="spacer"></div>

</div>

<!-- hidden video element -->
<video id="video-el" style="display:none" playsinline muted></video>

<script>
// ============================================================
//  STATE & CONSTANTS
// ============================================================
const S = {
  name: '', line1: '', line2: '',
  number: '', place: '', height: '',
  notes: '',
  mode: 'dark',
  videoLoaded: false,
};

const W   = 1080;          // canvas render width (always)
const PAD = 24;            // edge padding for video
const FS  = 24;            // font size on canvas
const LH  = FS * 1.18;    // ~28.32px
const LS  = '9.6px';      // letter-spacing (40% of 24px)
const G12 = 12, G24 = 24, G60 = 60;
const CONTENT_PAD = 80;   // breathing room above/below text block

// ============================================================
//  MONOGRAM  — inlined SVG, no server needed
// ============================================================
const MONO_SVG = `<svg width="143" height="84" viewBox="0 0 143 84" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M75.5852 29.808V35.64H44.3192V0H74.3432V5.832H50.7992V14.634H73.1552V19.926H50.7992V29.808H75.5852Z" fill="COLOR"/><path d="M0 48H15.228C21.42 48 25.974 49.638 28.89 52.914C31.806 56.19 33.264 60.456 33.264 65.712C33.264 71.364 31.86 75.774 29.052 78.942C26.28 82.074 21.87 83.64 15.822 83.64H0V48ZM15.66 77.808C19.368 77.808 22.14 76.908 23.976 75.108C25.848 73.308 26.784 70.176 26.784 65.712C26.784 62.04 25.902 59.142 24.138 57.018C22.374 54.894 19.35 53.832 15.066 53.832H6.48V77.808H15.66Z" fill="COLOR"/><path d="M51.2312 62.256C54.9392 61.932 57.7112 60.996 59.5472 59.448C61.3832 57.864 62.3012 56.028 62.3012 53.94C62.3012 53.436 62.2292 53.04 62.0852 52.752H61.9232C61.7792 53.724 61.3832 54.462 60.7352 54.966C60.0872 55.47 59.2772 55.722 58.3052 55.722C57.1172 55.722 56.1272 55.38 55.3352 54.696C54.5792 53.976 54.2012 52.968 54.2012 51.672C54.2012 50.34 54.6872 49.332 55.6592 48.648C56.6672 47.928 57.9992 47.568 59.6552 47.568C61.9232 47.568 63.7052 48.198 65.0012 49.458C66.2972 50.682 66.9452 52.266 66.9452 54.21C66.9452 56.514 66.3152 58.602 65.0552 60.474C63.8312 62.346 62.0312 63.858 59.6552 65.01C57.3152 66.162 54.5072 66.846 51.2312 67.062V62.256Z" fill="COLOR"/><path d="M112.398 75.324H94.4165L91.2845 83.64H84.4265L97.9265 48H108.834L122.334 83.64H115.53L112.398 75.324ZM110.4 70.032L104.46 54.48H102.3L96.4145 70.032H110.4Z" fill="COLOR"/></svg>`;

function makeMono(color) {
  const svg  = MONO_SVG.replace(/COLOR/g, color);
  const blob = new Blob([svg], { type: 'image/svg+xml' });
  const img  = new Image();
  img.src    = URL.createObjectURL(blob);
  return img;
}

const monoWhite = makeMono('white'); // dark mode
const monoBlack = makeMono('black'); // light mode
// Both load synchronously from blob URLs in modern browsers;
// trigger a re-render once they're ready just in case.
monoWhite.onload = monoBlack.onload = scheduleRender;

// ============================================================
//  ELEMENTS & FONT
// ============================================================
const preview = document.getElementById('preview');
const pCtx    = preview.getContext('2d');
const videoEl = document.getElementById('video-el');

const fontFace = new FontFace('Monotalic', 'url(Sources/Monotalic-WideMedium.ttf)');
fontFace.load().then(f => { document.fonts.add(f); scheduleRender(); });

// ============================================================
//  INPUTS
// ============================================================
['name','line1','line2','number','place','height','notes'].forEach(id => {
  const el = document.getElementById('f-' + id);
  el.addEventListener('input', () => {
    S[id] = el.value;
    if (id === 'notes') autoGrow(el);
    scheduleRender();
  });
});

function autoGrow(el) {
  el.style.height = 'auto';
  el.style.height = el.scrollHeight + 'px';
}

document.getElementById('video-input').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  document.getElementById('video-name').textContent = file.name;
  videoEl.loop = true;
  videoEl.muted = true;
  videoEl.src = URL.createObjectURL(file);
  videoEl.load();
  S.videoLoaded = true;
  videoEl.addEventListener('canplay', () => {
    videoEl.play().catch(() => {});
    startRenderLoop();
  }, { once: true });
});

function setMode(m) {
  S.mode = m;
  document.getElementById('btn-dark').classList.toggle('active',  m === 'dark');
  document.getElementById('btn-light').classList.toggle('active', m === 'light');
  scheduleRender();
}

// ============================================================
//  RENDER SCHEDULING
// ============================================================

/** Draw story to preview canvas, then fit it to the viewport. */
function renderPreview() {
  drawStory(pCtx, W);
  const cH = pCtx.canvas.height;
  let scale;
  if (window.innerWidth <= 768) {
    // Mobile: fill the available width (minus wrap padding)
    scale = Math.min(1, (window.innerWidth - 20) / W);
  } else {
    // Desktop: fit within available height, max 50%
    const availH = window.innerHeight - 20 - 48;
    scale = Math.min(0.5, availH / cH);
  }
  preview.style.width = Math.round(W * scale) + 'px';
}

let rafPending = false;
function scheduleRender() {
  if (!rafPending) {
    rafPending = true;
    requestAnimationFrame(() => { rafPending = false; renderPreview(); });
  }
}

let loopRaf = null;
function startRenderLoop() {
  if (loopRaf) cancelAnimationFrame(loopRaf);
  function loop() {
    renderPreview();
    loopRaf = requestAnimationFrame(loop);
  }
  loop();
}

// ============================================================
//  CORE DRAW
//  Width is always W (1080). Height is calculated dynamically —
//  grows if notes content is taller than the standard top section.
// ============================================================
function drawStory(ctx, cW) {
  const dark = S.mode === 'dark';
  const BG   = dark ? '#000' : '#fff';
  const FG   = dark ? '#fff' : '#000';
  const FG30 = dark ? 'rgba(255,255,255,0.3)' : 'rgba(0,0,0,0.3)';

  // — Font must be set before measureText (measurement pass)
  ctx.font = `${FS}px Monotalic`;
  if ('letterSpacing' in ctx) ctx.letterSpacing = LS;

  // — Video geometry
  const vAR = (S.videoLoaded && videoEl.videoWidth)
              ? videoEl.videoHeight / videoEl.videoWidth : 9 / 16;
  const vidW = cW - PAD * 2;
  const vidH = vidW * vAR;
  const symH = (1920 - vidH) / 2;

  // — Determine visible rows (only show rows with actual data)
  const hasNumber      = !!S.number;
  const hasName        = !!S.name;
  const hasLineage     = !!(S.line1 || S.line2);
  const hasHeightPlace = !!(S.height || S.place);
  const hasNotes       = !!S.notes;

  // — Name column width (all other rows align to this)
  const nameW = hasName ? ctx.measureText(S.name.toUpperCase()).width : 0;

  // — Notes wrap at name width (falls back to wide margin if no name)
  const notesWrapW = nameW > 0 ? nameW : cW - PAD * 8;
  const notesLines = hasNotes
    ? wrapText(ctx, S.notes.toUpperCase(), notesWrapW)
    : [];

  // — Build row list with gaps
  const rows = [];
  if (hasNumber)      rows.push({ type: 'number'       });
  if (hasName)        rows.push({ type: 'name'         });
  if (hasLineage)     rows.push({ type: 'lineage'      });
  if (hasHeightPlace) rows.push({ type: 'height_place' });
  if (hasNotes) {
    rows.push({ type: 'notes_label' });
    rows.push({ type: 'notes'       });
  }
  for (let i = 0; i < rows.length; i++) {
    if (i === 0) { rows[i].gap = 0; continue; }
    // All rows use LH spacing (gap = 0), except the notes section which gets a bigger break
    rows[i].gap = (rows[i].type === 'notes_label') ? G60 : 0;
  }

  // — Block height (only from visible rows)
  let blockH = 0;
  for (const row of rows) {
    blockH += row.gap;
    blockH += (row.type === 'notes') ? LH * notesLines.length : LH;
  }

  // — Top section: grows if content is taller than standard
  // Round to even integers — H.264 encoding requires even dimensions
  const topH = Math.ceil(Math.max(symH, blockH + CONTENT_PAD * 2) / 2) * 2;
  const botH = Math.ceil(symH / 2) * 2;
  const cH   = Math.ceil((topH + vidH + botH) / 2) * 2;
  const vidY = topH;

  // — Set canvas size (clears state)
  ctx.canvas.width  = cW;
  ctx.canvas.height = cH;

  // — Re-apply font after resize
  ctx.font = `${FS}px Monotalic`;
  if ('letterSpacing' in ctx) ctx.letterSpacing = LS;
  ctx.textBaseline = 'alphabetic';

  // — Background
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, cW, cH);

  // —— TOP TEXT BLOCK ——————————————————————————————————————
  let y = topH / 2 - blockH / 2;

  for (const row of rows) {
    y += row.gap;
    y += LH;
    ctx.textAlign = 'center';
    ctx.fillStyle = FG;

    switch (row.type) {
      case 'number': {
        const noStr = '(' + String(S.number).padStart(2, '0') + ')';
        fillTextLS(ctx, noStr, cW / 2, y);
        break;
      }
      case 'name': {
        fillTextLS(ctx, S.name.toUpperCase(), cW / 2, y);
        break;
      }
      case 'lineage': {
        const l1 = (S.line1 || '').toUpperCase();
        const l2 = (S.line2 || '').toUpperCase();
        // Measure actual text bounds for precise line positioning
        const m       = ctx.measureText('A');
        const textTop = y - m.actualBoundingBoxAscent;   // top of caps
        const textBot = y + (m.actualBoundingBoxDescent || 0); // bottom of caps (≈ baseline)
        const ruleDrawn = drawLineageRow(ctx, l1, l2, hasName ? S.name.toUpperCase() : '', cW, y, FG, textBot);
        // Vertical center line only when a horizontal rule was actually drawn
        if (ruleDrawn) {
          ctx.save();
          ctx.strokeStyle = FG;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(cW / 2, textBot); // flush with bottom of text
          ctx.lineTo(cW / 2, textTop); // flush with top of text
          ctx.stroke();
          ctx.restore();
        }
        break;
      }
      case 'height_place': {
        const spaceW = ctx.measureText('\u00A0').width;
        const heightStr = S.height ? S.height.toUpperCase() : '';
        const placeStr  = S.place  ? S.place.toUpperCase()  : '';
        const heightW = heightStr ? ctx.measureText(heightStr).width : 0;
        const placeW  = placeStr  ? ctx.measureText(placeStr).width  : 0;
        const minW = heightW + (heightW && placeW ? spaceW * 2 : 0) + placeW;
        const rowW = Math.max(nameW, minW);
        const rowX = cW / 2 - rowW / 2;
        if (heightStr) {
          ctx.textAlign = 'left';
          fillTextLS(ctx, heightStr, rowX, y);
        }
        if (placeStr) {
          ctx.textAlign = 'right';
          fillTextLS(ctx, placeStr, rowX + rowW, y);
        }
        ctx.textAlign = 'center';
        break;
      }
      case 'notes_label': {
        ctx.fillStyle = FG;
        fillTextLS(ctx, '(NOTES)', cW / 2, y);
        break;
      }
      case 'notes': {
        notesLines.forEach((line, i) => {
          fillTextLS(ctx, line, cW / 2, y + i * LH);
        });
        if (notesLines.length > 1) y += LH * (notesLines.length - 1);
        break;
      }
    }
  }

  // —— VIDEO ————————————————————————————————————————————————
  if (S.videoLoaded && videoEl.readyState >= 1) {
    ctx.save();
    ctx.beginPath();
    rrect(ctx, PAD, vidY, vidW, vidH, 12);
    ctx.clip();
    ctx.drawImage(videoEl, PAD, vidY, vidW, vidH);
    ctx.restore();
  }

  // —— BOTTOM SECTION — monogram ————————————————————————————
  const mono = dark ? monoWhite : monoBlack;
  if (mono.complete && mono.naturalWidth) {
    const mW = 64;
    const mH = mW * (84 / 143);
    ctx.drawImage(mono, cW / 2 - mW / 2, vidY + vidH + botH / 2 - mH / 2, mW, mH);
  }
}

// ============================================================
//  HELPERS
// ============================================================

function fillTextLS(ctx, text, x, y) {
  if ('letterSpacing' in ctx) {
    ctx.letterSpacing = LS;
    ctx.fillText(text, x, y);
    return;
  }
  // fallback: manual character spacing
  const sp = 9.6;
  const chars = [...text];
  const widths = chars.map(c => ctx.measureText(c).width + sp);
  const total  = widths.reduce((a, b) => a + b, 0) - sp;
  const savedAlign = ctx.textAlign;
  let cx = ctx.textAlign === 'center' ? x - total / 2
         : ctx.textAlign === 'right'  ? x - total : x;
  ctx.textAlign = 'left';
  chars.forEach((c, i) => { ctx.fillText(c, cx, y); cx += widths[i]; });
  ctx.textAlign = savedAlign;
}

/** Lineage row — total width matches horse name.
 *  A word-space gap sits on each side of the rule.
 *  Returns true if a horizontal rule was drawn, false otherwise. */
function drawLineageRow(ctx, l1, l2, horseName, cW, y, color, ruleY) {
  if ('letterSpacing' in ctx) ctx.letterSpacing = LS;

  ctx.fillStyle = color;

  // If only one side is filled, just center it — no rule
  if (!l1 || !l2) {
    ctx.textAlign = 'center';
    fillTextLS(ctx, l1 || l2, cW / 2, y);
    ctx.textAlign = 'center';
    return false;
  }

  const horseW = ctx.measureText(horseName).width;
  const l1W    = ctx.measureText(l1).width;
  const l2W    = ctx.measureText(l2).width;
  const spaceW = ctx.measureText('\u00A0').width;

  // Row width = horse name width, or names + 2 spaces minimum
  const minW = l1W + spaceW * 2 + l2W;
  const rowW = Math.max(horseW, minW);
  const rowX = cW / 2 - rowW / 2;

  ctx.textAlign = 'left';
  fillTextLS(ctx, l1, rowX, y);
  ctx.textAlign = 'right';
  fillTextLS(ctx, l2, rowX + rowW, y);

  // Rule with a word-space gap on each side
  const rx1 = rowX + l1W + spaceW;
  const rx2 = rowX + rowW - l2W - spaceW;
  const lineRuleY = ruleY !== undefined ? ruleY : y + (ctx.measureText('A').actualBoundingBoxDescent || 0);
  let ruleDrawn = false;
  if (rx2 - rx1 > 0) {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth   = 2;
    ctx.beginPath();
    ctx.moveTo(rx1, lineRuleY);
    ctx.lineTo(rx2, lineRuleY);
    ctx.stroke();
    ctx.restore();
    ruleDrawn = true;
  }

  ctx.textAlign = 'center';
  return ruleDrawn;
}

function wrapText(ctx, text, maxWidth) {
  if ('letterSpacing' in ctx) ctx.letterSpacing = LS;
  const words = text.split(' ');
  const lines = [];
  let cur = '';
  for (const w of words) {
    const test = cur ? cur + ' ' + w : w;
    if (ctx.measureText(test).width > maxWidth && cur) {
      lines.push(cur); cur = w;
    } else { cur = test; }
  }
  if (cur) lines.push(cur);
  return lines.length ? lines : [''];
}

function rrect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.arcTo(x + w, y,     x + w, y + r,     r);
  ctx.lineTo(x + w, y + h - r);
  ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
  ctx.lineTo(x + r, y + h);
  ctx.arcTo(x,     y + h, x,     y + h - r, r);
  ctx.lineTo(x,     y + r);
  ctx.arcTo(x,     y,     x + r, y,         r);
  ctx.closePath();
}

// ============================================================
//  EXPORT — offline seek-based render, works on all browsers
//  Seeks the video frame-by-frame, draws each frame, encodes
//  with WebCodecs + mp4-muxer. No real-time capture, no tab
//  dependency.
// ============================================================
let exporting = false;

async function startExport() {
  if (exporting) return;
  if (!S.videoLoaded) {
    document.getElementById('export-status').textContent = 'Upload a video first.';
    return;
  }

  exporting = true;
  const statusEl = document.getElementById('export-status');
  const btnEl    = document.getElementById('btn-export');

  function done(msg) {
    statusEl.textContent = msg;
    btnEl.textContent = '→ Export video';
    exporting = false;
    videoEl.muted = true;
    videoEl.loop  = true;
    videoEl.play().catch(() => {});
    startRenderLoop();
  }

  statusEl.textContent = 'Preparing…';
  btnEl.textContent    = '→ Exporting…';

  if (loopRaf) { cancelAnimationFrame(loopRaf); loopRaf = null; }
  videoEl.pause();
  videoEl.loop  = false;
  videoEl.muted = true;

  // Seek to start and wait for first frame to be ready
  videoEl.currentTime = 0;
  await new Promise(res => {
    let d = false;
    const cb = () => { if (!d) { d = true; res(); } };
    videoEl.addEventListener('seeked', cb, { once: true });
    setTimeout(cb, 800);
  });

  drawStory(pCtx, W);
  const cW       = preview.width;
  const cH       = preview.height;
  const duration = videoEl.duration;

  if (!duration || !isFinite(duration) || duration <= 0) {
    done('Could not read video duration'); return;
  }

  const fps         = 60;
  const totalFrames = Math.ceil(duration * fps);

  statusEl.textContent = `Preparing… ${cW}×${cH}`;

  // ── Wait for mp4-muxer ────────────────────────────────────
  await new Promise(res => {
    const check = () => window.mp4Muxer ? res() : setTimeout(check, 50);
    check();
  });
  const { Muxer, ArrayBufferTarget } = window.mp4Muxer;

  const target = new ArrayBufferTarget();
  const muxer  = new Muxer({
    target,
    video: { codec: 'avc', width: cW, height: cH },
    fastStart: 'in-memory',
    firstTimestampBehavior: 'offset',
  });

  // ── Probe codec ───────────────────────────────────────────
  const codecCandidates = ['avc1.640033', 'avc1.4D0033', 'avc1.640028', 'avc1.4D0028', 'avc1.42E028', 'avc1.42001E'];
  let selectedCodec = null;
  for (const c of codecCandidates) {
    try {
      const r = await VideoEncoder.isConfigSupported({ codec: c, width: cW, height: cH, bitrate: 8_000_000, framerate: fps });
      if (r.supported) { selectedCodec = c; break; }
    } catch (_) {}
  }
  if (!selectedCodec) { done('No supported H.264 codec found'); return; }
  console.log('[export] codec:', selectedCodec, `${cW}×${cH} ${fps}fps ${totalFrames} frames`);

  let encoderError = null;
  const videoEncoder = new VideoEncoder({
    output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),
    error:  e => { encoderError = e; console.error('[export] encoder error:', e); },
  });

  try {
    videoEncoder.configure({ codec: selectedCodec, width: cW, height: cH, bitrate: 8_000_000, framerate: fps });
  } catch (e) {
    done(`Configure failed: ${e.message}`); return;
  }

  // ── Seek-based render loop ────────────────────────────────
  for (let i = 0; i < totalFrames; i++) {
    if (encoderError) { done(`Encoder error: ${encoderError.message}`); return; }

    const t = i / fps;

    // Seek to this frame's timestamp
    videoEl.currentTime = t;
    await new Promise(res => {
      videoEl.addEventListener('seeked', res, { once: true });
    });

    // Draw the composed frame
    drawStory(pCtx, W);

    // VideoFrame via ImageBitmap — broader compat than canvas directly
    const bitmap = await createImageBitmap(preview);
    const frame  = new VideoFrame(bitmap, {
      timestamp: Math.round(t * 1_000_000),
      duration:  Math.round(1_000_000 / fps),
    });
    bitmap.close();
    videoEncoder.encode(frame, { keyFrame: i % (fps * 2) === 0 });
    frame.close();

    // Let encoder breathe if queue is building up
    while (videoEncoder.encodeQueueSize > 10) {
      await new Promise(r => setTimeout(r, 16));
    }

    statusEl.textContent = `Exporting… ${Math.round(((i + 1) / totalFrames) * 100)}%`;
  }

  if (encoderError) { done(`Encoder error: ${encoderError.message}`); return; }

  await videoEncoder.flush();
  videoEncoder.close();
  muxer.finalize();

  const blob = new Blob([target.buffer], { type: 'video/mp4' });
  Object.assign(document.createElement('a'), {
    href: URL.createObjectURL(blob),
    download: 'equipe-danvers-story.mp4',
  }).click();
  done('Done ✓');
}

// ============================================================
//  INIT
// ============================================================
window.addEventListener('resize', scheduleRender);
scheduleRender();
</script>
</body>
</html>
