<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Equipe d'Anvers — Story Builder</title>
<style>
@font-face {
  font-family: 'Monotalic';
  src: url('Sources/Monotalic-WideMedium.ttf') format('truetype');
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  background: #000;
  color: #fff;
  font-family: 'Monotalic', monospace;
  font-size: 10px;
  line-height: 1.18;
  letter-spacing: 4px;
  text-transform: uppercase;
  height: 100vh;
  overflow: hidden;
  display: flex;
}

.wrap {
  display: flex;
  width: 100%;
  height: 100%;
  padding: 10px;
  gap: 10px;
}

/* ——— FORM PANEL ——— */
.form-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  padding: 24px;
  overflow-y: auto;
  min-width: 0;
}

.form-inner {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

/* section = label + fields, spaced by line-height only */
.section {
  display: flex;
  flex-direction: column;
  gap: 0;
}

.section-label {
  opacity: 0.3;
  display: block;
  margin-bottom: 4px;
}

/* each field is label + input on one line */
.field {
  display: flex;
  align-items: baseline;
}

.field + .field {
  margin-top: 0; /* lines sit at natural line-height */
}

.lbl {
  flex-shrink: 0;
  white-space: nowrap;
  margin-right: 0.4ch;
}

input[type="text"],
textarea {
  flex: 1;
  background: transparent;
  border: none;
  outline: none;
  color: #fff;
  font-family: 'Monotalic', monospace;
  font-size: 10px;
  line-height: 1.18;
  letter-spacing: 4px;
  text-transform: uppercase;
  padding: 0;
  margin: 0;
  caret-color: #fff;
  resize: none;
  overflow: hidden;
  display: block;
  width: 100%;
  min-width: 0;
}

textarea { min-height: calc(10px * 1.18); }

input::placeholder,
textarea::placeholder { opacity: 0.25; }

/* Mode toggle */
.toggle-row {
  display: flex;
  gap: 6px;
  margin-top: 4px;
}

.toggle-btn {
  height: 16px;
  width: 96px;
  border-radius: 999px;
  border: 1px solid #fff;
  background: transparent;
  cursor: pointer;
  transition: background 0.15s;
  padding: 0;
  appearance: none;
  -webkit-appearance: none;
}

.toggle-btn.active { background: #fff; }

/* action links */
.action {
  cursor: pointer;
  display: block;
  margin-top: 4px;
}
.action:hover { opacity: 0.6; }

.status {
  opacity: 0.3;
  font-size: 10px;
  letter-spacing: 4px;
  display: block;
  min-height: calc(10px * 1.18);
}

/* Footer */
.form-footer {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  padding-top: 24px;
  flex-shrink: 0;
}

.monogram-footer {
  height: 18px;
  width: auto; /* preserve 143:84 ratio */
  filter: invert(1);
  flex-shrink: 0;
}

/* ——— PREVIEW PANEL ——— */
.preview-panel {
  flex-shrink: 0;
  display: flex;
  align-items: center;
  height: 100%;
}

.preview-wrap {
  border: 2px solid rgba(255,255,255,0.4);
  border-radius: 7px;
  overflow: hidden;
}

#preview {
  display: block;
  /* Width is set by JS after each render. Height follows intrinsic ratio. */
  height: auto;
}

/* ——— SPACER ——— */
.spacer { flex: 1; min-width: 0; }
</style>
</head>
<body>
<div class="wrap">

  <!-- FORM PANEL -->
  <div class="form-panel">
    <div class="form-inner">

      <div>
        <p>Equipe d'Anvers</p>
        <p>(IG) Story Builder</p>
      </div>

      <!-- Identity -->
      <div class="section">
        <span class="section-label">Identity</span>
        <div class="field"><span class="lbl">No.:</span><input type="text" id="f-number" placeholder="02" autocomplete="off"></div>
        <div class="field"><span class="lbl">Name:</span><input type="text" id="f-name" placeholder="Horse name" autocomplete="off"></div>
        <div class="field"><span class="lbl">Line 1:</span><input type="text" id="f-line1" placeholder="Mother" autocomplete="off"></div>
        <div class="field"><span class="lbl">Line 2:</span><input type="text" id="f-line2" placeholder="Father" autocomplete="off"></div>
      </div>

      <!-- Competition -->
      <div class="section">
        <span class="section-label">Competition</span>
        <div class="field"><span class="lbl">Place:</span><input type="text" id="f-place" placeholder="Peelbergen" autocomplete="off"></div>
        <div class="field"><span class="lbl">Height:</span><input type="text" id="f-height" placeholder="1.20" autocomplete="off"></div>
      </div>

      <!-- Notes -->
      <div class="section">
        <span class="section-label">Notes</span>
        <textarea id="f-notes" placeholder="Extra information..."></textarea>
      </div>

      <!-- Mode -->
      <div class="section">
        <span class="section-label">Mode</span>
        <div class="toggle-row">
          <button class="toggle-btn active" id="btn-dark"  onclick="setMode('dark')"></button>
          <button class="toggle-btn"        id="btn-light" onclick="setMode('light')"></button>
        </div>
      </div>

      <!-- Source -->
      <div class="section">
        <span class="section-label">Source</span>
        <span class="action" onclick="document.getElementById('video-input').click()">→ Upload video</span>
        <input type="file" id="video-input" accept="video/*" style="display:none">
        <span class="status" id="video-name"></span>
      </div>

      <!-- Export -->
      <div class="section">
        <span class="section-label">Export</span>
        <span class="action" id="btn-export" onclick="startExport()">→ Export video</span>
        <span class="status" id="export-status"></span>
      </div>

    </div>

    <!-- Footer -->
    <div class="form-footer">
      <img src="Sources/Monogram.svg" class="monogram-footer" alt="E D'A">
      <p>A Graphic Tool<br>by Typograaf</p>
      <p>Version 01<br>2026/02/28</p>
    </div>
  </div>

  <!-- PREVIEW -->
  <div class="preview-panel">
    <div class="preview-wrap">
      <canvas id="preview" width="810" height="1440"></canvas>
    </div>
  </div>

  <div class="spacer"></div>

</div>

<!-- hidden video element -->
<video id="video-el" style="display:none" playsinline muted></video>

<script>
// ============================================================
//  STATE & CONSTANTS
// ============================================================
const S = {
  name: '', line1: '', line2: '',
  number: '', place: '', height: '',
  notes: '',
  mode: 'dark',
  videoLoaded: false,
};

const W   = 1080;          // canvas render width (always)
const PAD = 24;            // edge padding for video
const FS  = 24;            // font size on canvas
const LH  = FS * 1.18;    // ~28.32px
const LS  = '9.6px';      // letter-spacing (40% of 24px)
const G12 = 12, G24 = 24, G60 = 60;
const CONTENT_PAD = 80;   // breathing room above/below text block

// ============================================================
//  MONOGRAM  — inlined SVG, no server needed
// ============================================================
const MONO_SVG = `<svg width="143" height="84" viewBox="0 0 143 84" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M75.5852 29.808V35.64H44.3192V0H74.3432V5.832H50.7992V14.634H73.1552V19.926H50.7992V29.808H75.5852Z" fill="COLOR"/><path d="M0 48H15.228C21.42 48 25.974 49.638 28.89 52.914C31.806 56.19 33.264 60.456 33.264 65.712C33.264 71.364 31.86 75.774 29.052 78.942C26.28 82.074 21.87 83.64 15.822 83.64H0V48ZM15.66 77.808C19.368 77.808 22.14 76.908 23.976 75.108C25.848 73.308 26.784 70.176 26.784 65.712C26.784 62.04 25.902 59.142 24.138 57.018C22.374 54.894 19.35 53.832 15.066 53.832H6.48V77.808H15.66Z" fill="COLOR"/><path d="M51.2312 62.256C54.9392 61.932 57.7112 60.996 59.5472 59.448C61.3832 57.864 62.3012 56.028 62.3012 53.94C62.3012 53.436 62.2292 53.04 62.0852 52.752H61.9232C61.7792 53.724 61.3832 54.462 60.7352 54.966C60.0872 55.47 59.2772 55.722 58.3052 55.722C57.1172 55.722 56.1272 55.38 55.3352 54.696C54.5792 53.976 54.2012 52.968 54.2012 51.672C54.2012 50.34 54.6872 49.332 55.6592 48.648C56.6672 47.928 57.9992 47.568 59.6552 47.568C61.9232 47.568 63.7052 48.198 65.0012 49.458C66.2972 50.682 66.9452 52.266 66.9452 54.21C66.9452 56.514 66.3152 58.602 65.0552 60.474C63.8312 62.346 62.0312 63.858 59.6552 65.01C57.3152 66.162 54.5072 66.846 51.2312 67.062V62.256Z" fill="COLOR"/><path d="M112.398 75.324H94.4165L91.2845 83.64H84.4265L97.9265 48H108.834L122.334 83.64H115.53L112.398 75.324ZM110.4 70.032L104.46 54.48H102.3L96.4145 70.032H110.4Z" fill="COLOR"/></svg>`;

function makeMono(color) {
  const svg  = MONO_SVG.replace(/COLOR/g, color);
  const blob = new Blob([svg], { type: 'image/svg+xml' });
  const img  = new Image();
  img.src    = URL.createObjectURL(blob);
  return img;
}

const monoWhite = makeMono('white'); // dark mode
const monoBlack = makeMono('black'); // light mode
// Both load synchronously from blob URLs in modern browsers;
// trigger a re-render once they're ready just in case.
monoWhite.onload = monoBlack.onload = scheduleRender;

// ============================================================
//  ELEMENTS & FONT
// ============================================================
const preview = document.getElementById('preview');
const pCtx    = preview.getContext('2d');
const videoEl = document.getElementById('video-el');

const fontFace = new FontFace('Monotalic', 'url(Sources/Monotalic-WideMedium.ttf)');
fontFace.load().then(f => { document.fonts.add(f); scheduleRender(); });

// ============================================================
//  INPUTS
// ============================================================
['name','line1','line2','number','place','height','notes'].forEach(id => {
  const el = document.getElementById('f-' + id);
  el.addEventListener('input', () => {
    S[id] = el.value;
    if (id === 'notes') autoGrow(el);
    scheduleRender();
  });
});

function autoGrow(el) {
  el.style.height = 'auto';
  el.style.height = el.scrollHeight + 'px';
}

document.getElementById('video-input').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  document.getElementById('video-name').textContent = file.name;
  videoEl.loop = true;
  videoEl.muted = true;
  videoEl.src = URL.createObjectURL(file);
  videoEl.load();
  S.videoLoaded = true;
  videoEl.addEventListener('canplay', () => {
    videoEl.play().catch(() => {});
    startRenderLoop();
  }, { once: true });
});

function setMode(m) {
  S.mode = m;
  document.getElementById('btn-dark').classList.toggle('active',  m === 'dark');
  document.getElementById('btn-light').classList.toggle('active', m === 'light');
  scheduleRender();
}

// ============================================================
//  RENDER SCHEDULING
// ============================================================

/** Draw story to preview canvas, then fit it to the viewport. */
function renderPreview() {
  drawStory(pCtx, W);
  // Scale so the preview fits with 24px top+bottom padding,
  // never larger than the actual export (1:1 scale).
  const cH     = pCtx.canvas.height;
  const availH = window.innerHeight - 20 - 48; // 20px wrap, 24px top+24px bottom
  const scale  = Math.min(1, availH / cH);
  preview.style.width = Math.round(W * scale) + 'px';
}

let rafPending = false;
function scheduleRender() {
  if (!rafPending) {
    rafPending = true;
    requestAnimationFrame(() => { rafPending = false; renderPreview(); });
  }
}

let loopRaf = null;
function startRenderLoop() {
  if (loopRaf) cancelAnimationFrame(loopRaf);
  function loop() {
    renderPreview();
    loopRaf = requestAnimationFrame(loop);
  }
  loop();
}

// ============================================================
//  CORE DRAW
//  Width is always W (1080). Height is calculated dynamically —
//  grows if notes content is taller than the standard top section.
// ============================================================
function drawStory(ctx, cW) {
  const dark = S.mode === 'dark';
  const BG   = dark ? '#000' : '#fff';
  const FG   = dark ? '#fff' : '#000';
  const FG30 = dark ? 'rgba(255,255,255,0.3)' : 'rgba(0,0,0,0.3)';

  // — Font must be set before measureText (measurement pass)
  ctx.font = `${FS}px Monotalic`;
  if ('letterSpacing' in ctx) ctx.letterSpacing = LS;

  // — Video geometry
  const vAR = (S.videoLoaded && videoEl.videoWidth)
              ? videoEl.videoHeight / videoEl.videoWidth : 9 / 16;
  const vidW = cW - PAD * 2;
  const vidH = vidW * vAR;
  const symH = (1920 - vidH) / 2;   // standard symmetric top = bottom

  // — Notes wrap (measurement pass, before canvas resize)
  const notesLines = S.notes
    ? wrapText(ctx, S.notes.toUpperCase(), cW - PAD * 8)
    : ['—'];

  // — Text block height
  const blockH = LH                         // (no.)
    + G24 + LH                              // horse name
    + G12 + LH                              // lineage
    + G12 + LH                              // height / place
    + G60 + LH                              // (notes) label
    + G12 + LH * notesLines.length;         // notes lines

  // — Top section: grows if content is taller than standard
  const topH = Math.max(symH, blockH + CONTENT_PAD * 2);
  const botH = symH;                         // bottom always stays symmetric
  const cH   = topH + vidH + botH;
  const vidY = topH;

  // — Set canvas size (clears state)
  ctx.canvas.width  = cW;
  ctx.canvas.height = cH;

  // — Re-apply font after resize
  ctx.font = `${FS}px Monotalic`;
  if ('letterSpacing' in ctx) ctx.letterSpacing = LS;
  ctx.textBaseline = 'alphabetic';

  // — Background
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, cW, cH);

  // —— TOP SECTION ——————————————————————————————————————————
  let y = topH / 2 - blockH / 2 + LH;

  // (No.)
  ctx.textAlign = 'center';
  const noStr = S.number ? '(' + String(S.number).padStart(2, '0') + ')' : '(00)';
  ctx.fillStyle = S.number ? FG : FG30;
  fillTextLS(ctx, noStr, cW / 2, y);
  y += G24 + LH;

  // Horse name
  const horseName = (S.name || 'Horse Name').toUpperCase();
  ctx.fillStyle = S.name ? FG : FG30;
  fillTextLS(ctx, horseName, cW / 2, y);
  y += G12 + LH;

  // Lineage row (mother ——— father)
  const l1 = (S.line1 || 'Mother').toUpperCase();
  const l2 = (S.line2 || 'Father').toUpperCase();
  ctx.fillStyle = (S.line1 || S.line2) ? FG : FG30;
  drawLineageRow(ctx, l1, l2, horseName, cW, y, (S.line1 || S.line2) ? FG : FG30);
  y += G12 + LH;

  // Height (left) + Place (right)
  ctx.fillStyle = (S.height || S.place) ? FG : FG30;
  ctx.textAlign = 'left';
  fillTextLS(ctx, (S.height || '—').toUpperCase(), PAD * 4, y);
  ctx.textAlign = 'right';
  fillTextLS(ctx, (S.place  || '—').toUpperCase(), cW - PAD * 4, y);
  y += G60 + LH;

  // (notes) label
  ctx.textAlign = 'center';
  ctx.fillStyle = FG30;
  fillTextLS(ctx, '(Notes)', cW / 2, y);
  y += G12 + LH;

  // Notes lines
  ctx.fillStyle = S.notes ? FG : FG30;
  notesLines.forEach((line, i) => {
    fillTextLS(ctx, line, cW / 2, y + i * LH);
  });

  // —— VIDEO ————————————————————————————————————————————————
  if (S.videoLoaded && videoEl.readyState >= 1) {
    ctx.save();
    ctx.beginPath();
    rrect(ctx, PAD, vidY, vidW, vidH, 12);
    ctx.clip();
    ctx.drawImage(videoEl, PAD, vidY, vidW, vidH);
    ctx.restore();
  }

  // —— BOTTOM SECTION — monogram ————————————————————————————
  const mono = dark ? monoWhite : monoBlack;
  if (mono.complete && mono.naturalWidth) {
    // Original SVG: 143×84. Scale to 64px wide, keep ratio.
    const mW = 64;
    const mH = mW * (84 / 143); // ~37.5px
    ctx.drawImage(mono, cW / 2 - mW / 2, vidY + vidH + botH / 2 - mH / 2, mW, mH);
  }
}

// ============================================================
//  HELPERS
// ============================================================

function fillTextLS(ctx, text, x, y) {
  if ('letterSpacing' in ctx) {
    ctx.letterSpacing = LS;
    ctx.fillText(text, x, y);
    return;
  }
  // fallback: manual character spacing
  const sp = 9.6;
  const chars = [...text];
  const widths = chars.map(c => ctx.measureText(c).width + sp);
  const total  = widths.reduce((a, b) => a + b, 0) - sp;
  const savedAlign = ctx.textAlign;
  let cx = ctx.textAlign === 'center' ? x - total / 2
         : ctx.textAlign === 'right'  ? x - total : x;
  ctx.textAlign = 'left';
  chars.forEach((c, i) => { ctx.fillText(c, cx, y); cx += widths[i]; });
  ctx.textAlign = savedAlign;
}

/** Lineage row — total width matches horse name.
 *  Rule fills the gap between l1 and l2.
 *  If no room for a rule, a single word-space separates them. */
function drawLineageRow(ctx, l1, l2, horseName, cW, y, color) {
  if ('letterSpacing' in ctx) ctx.letterSpacing = LS;

  const horseW = ctx.measureText(horseName).width;
  const l1W    = ctx.measureText(l1).width;
  const l2W    = ctx.measureText(l2).width;
  const spaceW = ctx.measureText('\u00A0').width; // non-breaking space

  // Row width = horse name width, or names + 1 space minimum
  const minW = l1W + spaceW + l2W;
  const rowW  = Math.max(horseW, minW);
  const rowX  = cW / 2 - rowW / 2;

  ctx.fillStyle = color;
  ctx.textAlign = 'left';
  fillTextLS(ctx, l1, rowX, y);
  ctx.textAlign = 'right';
  fillTextLS(ctx, l2, rowX + rowW, y);

  // Rule between them (only if there's actual space beyond 1 word-space)
  const rx1 = rowX + l1W;
  const rx2 = rowX + rowW - l2W;
  if (rx2 - rx1 > spaceW + 2) {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth   = 1;
    ctx.beginPath();
    ctx.moveTo(rx1, y - LH * 0.28);
    ctx.lineTo(rx2, y - LH * 0.28);
    ctx.stroke();
    ctx.restore();
  }

  ctx.textAlign = 'center';
}

function wrapText(ctx, text, maxWidth) {
  if ('letterSpacing' in ctx) ctx.letterSpacing = LS;
  const words = text.split(' ');
  const lines = [];
  let cur = '';
  for (const w of words) {
    const test = cur ? cur + ' ' + w : w;
    if (ctx.measureText(test).width > maxWidth && cur) {
      lines.push(cur); cur = w;
    } else { cur = test; }
  }
  if (cur) lines.push(cur);
  return lines.length ? lines : [''];
}

function rrect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.arcTo(x + w, y,     x + w, y + r,     r);
  ctx.lineTo(x + w, y + h - r);
  ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
  ctx.lineTo(x + r, y + h);
  ctx.arcTo(x,     y + h, x,     y + h - r, r);
  ctx.lineTo(x,     y + r);
  ctx.arcTo(x,     y,     x + r, y,         r);
  ctx.closePath();
}

// ============================================================
//  EXPORT
// ============================================================
let exporting = false;

async function startExport() {
  if (exporting) return;
  if (!S.videoLoaded) {
    document.getElementById('export-status').textContent = 'Upload a video first.';
    return;
  }

  exporting = true;
  const statusEl = document.getElementById('export-status');
  const btnEl    = document.getElementById('btn-export');
  statusEl.textContent = 'Recording…';
  btnEl.textContent    = '→ Recording…';

  const ec   = document.createElement('canvas');
  const ectx = ec.getContext('2d');

  if (loopRaf) { cancelAnimationFrame(loopRaf); loopRaf = null; }
  videoEl.pause();
  videoEl.loop = false;
  videoEl.currentTime = 0;
  await new Promise(res => videoEl.addEventListener('seeked', res, { once: true }));
  videoEl.muted = false;
  videoEl.play().catch(() => {});

  const mimeType = MediaRecorder.isTypeSupported('video/mp4')          ? 'video/mp4'
    : MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9'
    : 'video/webm';
  const ext = mimeType.startsWith('video/mp4') ? 'mp4' : 'webm';

  // First render to get final canvas dimensions
  drawStory(ectx, W);
  const stream = ec.captureStream(30);
  if (videoEl.captureStream) {
    videoEl.captureStream().getAudioTracks().forEach(t => stream.addTrack(t));
  }

  const chunks = [];
  const mr = new MediaRecorder(stream, { mimeType });
  mr.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
  mr.onstop = () => {
    const blob = new Blob(chunks, { type: mimeType });
    const url  = URL.createObjectURL(blob);
    const a    = document.createElement('a');
    a.href = url; a.download = `equipe-danvers-story.${ext}`; a.click();
    statusEl.textContent = 'Done ✓';
    btnEl.textContent    = '→ Export video';
    exporting = false;
    videoEl.loop = true;
    videoEl.muted = true;
    videoEl.play().catch(() => {});
    startRenderLoop();
  };

  mr.start(100);
  videoEl.addEventListener('ended', () => mr.stop(), { once: true });
  function exportLoop() {
    drawStory(ectx, W);
    if (!videoEl.ended) requestAnimationFrame(exportLoop);
    else mr.stop();
  }
  exportLoop();
}

// ============================================================
//  INIT
// ============================================================
window.addEventListener('resize', scheduleRender);
scheduleRender();
</script>
</body>
</html>
